import os
import sys
sys.path.append('/home/yang_liu/python_workspace/gaussian-splatting-lightning')

import json
import pickle
import torch
import torch_scatter
import alphashape
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from plyfile import PlyData, PlyElement
from argparse import ArgumentParser
from internal.utils.gaussian_model_loader import GaussianModelLoader
from internal.renderers.vanilla_trim_renderer import VanillaTrimRenderer
 
def voxel_filtering(voxel_size, xy_range, gt_xyz, target_xyz):
    assert len(xy_range) == 4, "Unrecognized xy_range format"
    with torch.no_grad():
        voxel_dim = torch.tensor([int((xy_range[2] - xy_range[0]) / voxel_size[0]), int((xy_range[3] - xy_range[1]) / voxel_size[1])])
        gt_voxel_index = torch.div(gt_xyz[::100, :2] - xy_range[None, :2], voxel_size[None, :], rounding_mode='floor')
        gt_voxel_index_1d = gt_voxel_index[:, 1] * voxel_dim[0] + gt_voxel_index[:, 0]
        
        gt_new_index, gt_unq_inv, _ = torch.unique(gt_voxel_index_1d, return_inverse=True, return_counts=True, dim=0)
        gt_vox_z_max = torch_scatter.scatter_max(gt_xyz[::100, 2], gt_unq_inv, dim=0)[0]
        mapper = - torch.ones(gt_new_index.long().max()+1, dtype=torch.long, device=gt_new_index.device)
        mapper[gt_new_index.long()] = torch.arange(gt_new_index.shape[0], device=gt_new_index.device)

        target_voxel_index = torch.div(target_xyz[:, :2] - xy_range[None, :2], voxel_size[None, :], rounding_mode='floor')
        target_voxel_index_1d = target_voxel_index[:, 1] * voxel_dim[0] + target_voxel_index[:, 0]
        target_new_index, target_unq_inv, _ = torch.unique(target_voxel_index_1d, return_inverse=True, return_counts=True, dim=0)
        mask = torch.isin(target_new_index, gt_new_index)
        z_max = torch.ones_like(target_new_index, dtype=gt_vox_z_max.dtype) * gt_vox_z_max.max()
        z_max[mask] = gt_vox_z_max[mapper[target_new_index[mask].long()]]
        z_max = z_max[target_unq_inv]

        mask = target_xyz[:, -1] < z_max

    return mask
 
 
if __name__ == '__main__':
    parser = ArgumentParser(description="Convert each panorama image to 6 perspective images")
    parser.add_argument("--gt_path", type=str, required=True, help="Path to the ground truth ply file")
    parser.add_argument("--transform_path", type=str, default=None, help="Path to the transformation txt file")
    parser.add_argument("--icp_path", type=str, default=None, help="Path to the transformation txt file generated by registration")
    parser.add_argument("--ckpt_path", type=str, required=True, help="Path to the checkpoint file")
    parser.add_argument("--voxel_size", type=float, default=0.1)

    args = parser.parse_args(sys.argv[1:])
    
    model, renderer = GaussianModelLoader.search_and_load(
        args.ckpt_path,
        sh_degree=3,
        device="cuda",
    )
    if isinstance(renderer, VanillaTrimRenderer):
        model._scaling = torch.cat((torch.ones_like(model._scaling[:, :1]) * 1e-8, model._scaling[:, [-2, -1]]), dim=1)

    with open(args.transform_path, 'r') as f:
        transform = torch.tensor(np.loadtxt(f), device="cuda").to(torch.float32)
    
    plydata = PlyData.read(args.gt_path)
    data = plydata.elements[0].data
    data_pd = pd.DataFrame(data)
    data_np = np.zeros(data_pd.shape)
    property_names = data[0].dtype.names
    for i, name in enumerate(property_names):
        data_np[:, i] = data_pd[name]
    x_min, x_max = np.min(data_np[:, 0]), np.max(data_np[:, 0])
    y_min, y_max = np.min(data_np[:, 1]), np.max(data_np[:, 1])

    gt_xyz = torch.tensor(data_np[:, :3], device="cuda").to(torch.float32)
    gt_xyz_homo = torch.cat([gt_xyz, torch.ones(gt_xyz.shape[0], 1, device="cuda")], dim=-1)
    gt_xyz = (gt_xyz_homo @ (torch.linalg.inv(transform).T))[:, :3]
    xy_range = torch.tensor([x_min, y_min, x_max, y_max], device="cuda")

    x_min, x_max = np.min(data_np[:, 0]), np.max(data_np[:, 0])
    y_min, y_max = np.min(data_np[:, 1]), np.max(data_np[:, 1])

    xyz_homo = torch.cat([model.get_xyz, torch.ones(model.get_xyz.shape[0], 1, device="cuda")], dim=-1)
    xyz_homo = (xyz_homo @ (torch.linalg.inv(transform).T))

    if args.icp_path is not None:
        with open(args.icp_path, 'r') as f:
            transform_icp = torch.tensor(np.loadtxt(f), device="cuda").to(torch.float32)
            xyz_homo = (xyz_homo @ (transform_icp.T))

    xyz = xyz_homo[:, :3]

    voxel_size = torch.tensor([args.voxel_size] * 2, device="cuda")
    vox_mask = voxel_filtering(voxel_size, xy_range, gt_xyz, xyz).bool()

    model.delete_gaussians(~vox_mask)
    checkpoint = torch.load(args.ckpt_path)
    model_params = model.to_parameter_structure()
    checkpoint["state_dict"]["gaussian_model._xyz"] = model_params.xyz
    checkpoint["state_dict"]["gaussian_model._opacity"] = model_params.opacities
    checkpoint["state_dict"]["gaussian_model._features_dc"] = model_params.features_dc
    checkpoint["state_dict"]["gaussian_model._features_rest"] = model_params.features_rest
    checkpoint["state_dict"]["gaussian_model._scaling"] = model_params.scales
    checkpoint["state_dict"]["gaussian_model._rotation"] = model_params.rotations
    checkpoint["state_dict"]["gaussian_model._features_extra"] = model_params.real_features_extra

    torch.save(checkpoint, args.ckpt_path.replace('.ckpt', '_vox_filtered.ckpt'))
    print(f"Voxel filtering completed. Checkpoint saved at {args.ckpt_path.replace('.ckpt', '_vox_filtered.ckpt')}")